#lang racket


;(fileToList (read-char arch) '())
(define fileToList (lambda (char lista) ; te pone todo los caracteres del archivo en una lista
                    (cond
                     ((eof-object? (peek-char arch)) (append lista (list char)))
                     (else (fileToList (read-char arch) (append lista (list char))))))) ; usar mejor foreach en vez de recursivo

;Cosas globales
(define estadosFinales '(101 102 103 104 105 106 200 201))
(define estados* '(101 102 105 209))
(define reservedWords '("println" "def" "if" "cond" "defn" "fn" "else" "true" "false" "nil" "cons" "first" "second" "rest" "next" "concat" "map" "apply" "filter" "reduce" "pmap" "let" "seq" "conj" "do" "and" "or" "not" "not=" "quote" "empty?" "take" "range" "doall" "time" "future" "delay" "promise"))

(define arch (open-input-file "c:\\datos.txt")) ; arbir archivo
(define listFile (fileToList (read-char arch) '())) ; lista con todo el archivo
(close-input-port arch)
(define outFile (open-output-file "c:\\datosSalida.html" #:exists 'replace))

;lista transiciones
(define transiciones '(
                       (0 #\space 0) (0 #\newline 201) (0 "number" 1) (1 "number" 1) (1 "letter-e" 101) (1 #\e 101) (1 "special" 101) (1 #\( 101) (1 #\) 101)  (1 #\space 101) (1 "eof" 101) (1 #\newline 101)
                       (1 #\. 2) (2 "number" 2) (2 "letter-e" 102) (2 "special" 102) (2 #\( 102) (2 #\) 102) (2 #\space 102) (2 #\newline 102) (2 "eof" 102) (2 #\e 3) (3 "number" 103)
                       (0 #\" 4) (4 "letter-e" 4) (4 #\e 4) (4 "number" 4) (4 #\space 4) (4 "special" 4) (4 #\( 4) (4 #\) 4) (4 #\" 104)
                       (0 "letter-e" 5) (0 #\e 5) (5 "letter-e" 5) (5 #\e 5) (5 "number" 5) (5 "special" 5) (5 #\( 105) (5 #\) 105) (5 #\space 105) (5 "eof" 105) (5 #\newline 105)
                       (0 #\; 6) (6 #\; 6) (6 "letter-e" 6) (6 #\e 6) (6 "number" 6) (6 #\" 6) (6 "special" 6) (6 #\( 6) (2 #\) 6) (6 #\< 6) (6 #\= 6) (6 #\> 6) (6 #\space 6) (6 #\newline 106)
                       (0 #\< 7) (0 #\> 7) (7 #\= 208) (7 "letter-e" 200) (7 #\e 200) (7 "number" 200) (7 "special" 200) (7 #\( 200) (7 #\) 200) (7 #\space 200) (7 "eof" 200) (7 #\newline 200)
                       (0 "special" 200)
                       (0 #\( 200) (0 #\) 200)
))


(define letterToSymbol (lambda (el)
         (cond
           ((pair? (memq el '(#\a #\b #\c #\d #\f #\g #\h #\i #\j #\k #\l #\m #\n #\o #\p #\q #\r #\s #\t #\u #\v #\w #\x #\y #\z #\A #\B #\C #\D #\E #\F #\G #\H #\I #\J #\K #\L #\M #\N #\O #\P #\Q #\R #\S #\T #\U #\V #\W #\X #\Y #\Z))) "letter-e")
           ((pair? (memq el '(#\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9 #\0))) "number")
           ((pair? (memq el '(#\{ #\} #\[ #\] #\+ #\- #\* #\/ #\# #\\ #\' #\? #\: #\, #\. #\&))) "special") ; para que reconozca bien 105 - poner parentesis como char en automata
           ((eof-object? el) "eof")
           (else el))))

(define estado*? (lambda (state)
                         (if (pair? (memq (car state) estados*)) #t #f)))

;(findPattern listFile 0 '() '((("begin"))))
(define findPattern (lambda (fileInList state word resFile)
                         (cond
                           ;Intento para que reconzca ultimo patron al final del archivo - ((null? fileInList) (if (null? word) (writeHTML (append resFile (list (list (list "end"))))) (findPattern fileInList (pattern transiciones word 0) '() resFile)))
                           ((null? fileInList) (writeHTML (append resFile (list (list (list "end"))))))
                           ((and (pair? state) (> (car state) 100)) (if (estado*? state)
                                                                         (findPattern fileInList (pattern transiciones (list (car fileInList)) 0) (list (car fileInList)) (append resFile (list (list state word))))
                                                                         (findPattern (cdr fileInList) 0 '() (append resFile (list (list state word))))))
                           ((and (pair? state) (= (car state) -1)) (findPattern (cdr fileInList) 0 '() (append resFile (list (list state word)))))
                           ((detectSpecial (car fileInList) word) (cond
                                                                    ((null? word) (findPattern fileInList (pattern transiciones (append word (list (car fileInList))) 0) (car fileInList) resFile))
                                                                    ((pair? (memq #\" word)) (findPattern fileInList (pattern transiciones (append word (list (car fileInList))) 0) (append word (list (car fileInList))) resFile))
                                                                    (else (findPattern fileInList (pattern transiciones (append word (list (car fileInList))) 0) word resFile))))
                           (else (findPattern (cdr fileInList) state (append word (list (car fileInList))) resFile)))))


;(encuentra listFile 0 '() '((("begin"))))
(define encuentra (lambda (file state word res)   ; ya respeta solo los newlines, si estan dentro de la palabra le vale malles.
                    (cond
                      ((null? file) (writeHTML (append res (list (list (list state) word)) (list (list (list "end"))))))
                      ;((null? file) (append res (list (list (list state) word)) (list (list "end"))))
                      ((= state -1) (encuentra (cdr file) 0 (append word (list (car file))) res))
                      ((> state 100) (if (pair? (memq state estados*))
                                         ;(list (append (list (car (reverse word))) file) (list (list (car file) word))) (list (append (list (car (reverse word))) file) (list (list (car file) word)))))
                                         (encuentra (append (list (car (reverse word))) file) 0 '() (append res (list (list (list state) (reverse (cdr (reverse word)))))))
                                         (encuentra file 0 '() (append res (list (list (list state) word))))))
                      (else (encuentra (cdr file) (followAFD transiciones (letterToSymbol (car file)) state) (append word (list (car file))) res)))))
                      
                                  
                   

;ESTO NO NONO! - MEDIO SIRVE PERO NO SRIVE BIEN Y LO QUIERO PERFECTO, ENTONCES ITNENTARÉ HACERLO CHAR POR CHAR
(define detectSpecial (lambda (el word) ;esta define en que punto debe de partir la palabra para buscar su estado con el automata. Esto es necesario porque se separan palabras antes de mandarselas al automata
                        (cond
                          ((and (pair? (memq #\; word)) (eq? el #\newline)) #t)
                          ((and (pair? (memq #\" word)) (eq? el #\")) #t)
                          ((and (not (pair? (memq #\; word))) (not (pair? (memq #\" word))) (or (eq? el #\() (eq? el #\)) (eq? el #\{) (eq? el #\}) (eq? el #\[) (eq? el #\]) (eq? el #\+) (eq? el #\-) (eq? el #\*) (eq? el #\/)
                               (eq? el #\#) (eq? el #\\) (eq? el #\') (eq? el #\=) (eq? el #\space) (eq? el #\newline)) #t))
                          (else #f))))


; (pattern transiciones listFile 0 '())
(define (pattern afd simbolos estado)
  (cond
    ((> estado 100) (list estado))
    ((= estado -1) (list -1))
    ((null? simbolos) (list -1))
    (else (pattern afd (cdr simbolos) (followAFD afd (letterToSymbol (car simbolos)) estado)))))


(define (followAFD afd simbolo estado)
  (cond
    ((null? afd) -1)
    ((pair? (car afd)) (max (followAFD (car afd) simbolo estado) (followAFD (cdr afd) simbolo estado)))
    ((not (pair? (car afd))) (if (and (eq? (cadr afd) simbolo) (eq? (car afd) estado)) (caddr afd) -1))
    (else (followAFD (cdr afd) simbolo estado))))


(define writeHTML (lambda (resList)
                    ;resList))
                        (for-each (lambda (el)
                          (cond
                            ((eq? (caar el) "begin") (writeHead))
                            ((eq? (caar el) "end") (writeEnd))
                            ;((pair? (memq #\space el)) (write-string (htmlTag (list-update el (index-of el #\newline) (lambda (x) " "))) outFile))
                            (else (write-string (htmlTag el) outFile)))) resList)))
                    

(define writeHead (lambda ()
                    (write-string "<!DOCTYPEhtml>" outFile)
                    (write-string "<html>" outFile)
                    (write-string "<head><title>SuperMegaCoolResaltador</title>" outFile)
                    (write-string "<link rel=\"stylesheet\" 'type=\"text/css\" 'href=\"index.css\" media=”screen”/></head>" outFile)
                    (write-string "<body>" outFile)
                    (write-string "<div>" outFile)))


(define writeEnd (lambda ()
                    (write-string "</div>" outFile)
                    (write-string "</body>" outFile)
                    (write-string "</html>" outFile)
                    (close-output-port outFile)))

                    

;(findPattern listFile 0 '() '((("begin"))))
(define htmlTag (lambda (listEl) ;-> recibe '((101) (#\1 #\2 #\3))
                         (cond
                           ((eq? (caar listEl) 101) (string-append "<span style=\"color: red\">" (list->string (cadr listEl)) "</span>"))
                           ((eq? (caar listEl) 102) (string-append "<span style=\"color: green\">" (list->string (cadr listEl)) "</span>"))
                           ((eq? (caar listEl) 103) (string-append "<span style=\"color: yellow\">" (list->string (cadr listEl)) "</span>"))
                           ((eq? (caar listEl) 104) (string-append "<span style=\"color: blue\">" (list->string (cadr listEl)) "</span>"))
                           ((eq? (caar listEl) 105) (if (member (list->string (cadr listEl)) reservedWords) (string-append "<span style=\"color:#bd42bd\">" (list->string (cadr listEl)) "</span>") (string-append "<span style=\"color:#5da28c\">" (list->string (cadr listEl)) "</span>"))) ; checar palabras reservadas aqui
                           ((eq? (caar listEl) 106) (string-append "<span style=\"color:#1a9fe5\">" (list->string (cadr listEl)) "</span><br>"))
                           ((eq? (caar listEl) 200) (string-append "<span style=\"color:#e1931e\">" (if (pair? (cadr listEl)) (list->string (cadr listEl))  (string (cadr listEl))) "</span>"))
                           ((eq? (caar listEl) 209) (string-append "<span style=\"color:#e817a2\">" (list->string (if (pair? (cadr listEl)) (cadr listEl) (list (cadr listEl)))) "</span>"))
                           ((eq? (caar listEl) 201) "<br>")
                           ((eq? (caar listEl) 202) (string (caadr listEl)))
                           ;((and (eq? (caar listEl) -1) (eq? (cadr listEl) #\space)) "  ")
                           (else (string-append "<span style=\"color:black\">"(list->string (cadr listEl))"</span>")))))



